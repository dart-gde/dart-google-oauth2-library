        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Credentials class / credentials Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="credentials" data-type="Credentials">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../credentials.html">credentials</a> &rsaquo; <a href="../credentials/Credentials.html">Credentials</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Credentials</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Credentials that prove that a client is allowed to access a resource on the
resource owner's behalf. These credentials are long-lasting and can be
safely persisted across multiple runs of the program.</p>
<p>Many authorization servers will attach an expiration date to a set of
credentials, along with a token that can be used to refresh the credentials
once they've expired. The <code>Client</code> will automatically refresh its
credentials when necessary. It's also possible to explicitly refresh them
via <code>Client.refreshCredentials</code> or <a class="crossref" href="../credentials/Credentials.html#refresh">Credentials.refresh</a>.</p>
<p>Note that a given set of credentials can only be refreshed once, so be sure
to save the refreshed credentials for future use.</p>
<pre class="source">
class Credentials {
 /// The token that is sent to the resource server to prove the authorization
 /// of a client.
 final String accessToken;

 /// The token that is sent to the authorization server to refresh the
 /// credentials. This is optional.
 final String refreshToken;

 /// The URL of the authorization server endpoint that's used to refresh the
 /// credentials. This is optional.
 final Uri tokenEndpoint;

 /// The specific permissions being requested from the authorization server.
 /// The scope strings are specific to the authorization server and may be
 /// found in its documentation.
 final List&lt;String&gt; scopes;

 /// The date at which these credentials will expire. This is likely to be a
 /// few seconds earlier than the server's idea of the expiration date.
 final DateTime expiration;

 /// Whether or not these credentials have expired. Note that it's possible the
 /// credentials will expire shortly after this is called. However, since the
 /// client's expiration date is kept a few seconds earlier than the server's,
 /// there should be enough leeway to rely on this.
 bool get isExpired =&gt; expiration != null &amp;&amp;
     new DateTime.now().isAfter(expiration);

 /// Whether it's possible to refresh these credentials.
 bool get canRefresh =&gt; refreshToken != null &amp;&amp; tokenEndpoint != null;

 /// Creates a new set of credentials.
 ///
 /// This class is usually not constructed directly; rather, it's accessed via
 /// [Client.credentials] after a [Client] is created by
 /// [AuthorizationCodeGrant]. Alternately, it may be loaded from a serialized
 /// form via [Credentials.fromJson].
 Credentials(
     this.accessToken,
     [this.refreshToken,
      this.tokenEndpoint,
      this.scopes,
      this.expiration]);

 /// Loads a set of credentials from a JSON-serialized form. Throws
 /// [FormatException] if the JSON is incorrectly formatted.
 factory Credentials.fromJson(String json) {
   void validate(bool condition, String message) {
     if (condition) return;
     throw new FormatException(
         "Failed to load credentials: $message.\n\n$json");
   }

   var parsed;
   try {
     parsed = JSON.parse(json);
   } catch (e) {
     // TODO(nweiz): narrow this catch clause once issue 6775 is fixed.
     validate(false, 'invalid JSON');
   }

   validate(parsed is Map, 'was not a JSON map');
   validate(parsed.containsKey('accessToken'),
       'did not contain required field "accessToken"');
   validate(parsed['accessToken'] is String,
       'required field "accessToken" was not a string, was '
       '${parsed["accessToken"]}');


   for (var stringField in ['refreshToken', 'tokenEndpoint']) {
     var value = parsed[stringField];
     validate(value == null || value is String,
         'field "$stringField" was not a string, was "$value"');
   }

   var scopes = parsed['scopes'];
   validate(scopes == null || scopes is List,
       'field "scopes" was not a list, was "$scopes"');

   var tokenEndpoint = parsed['tokenEndpoint'];
   if (tokenEndpoint != null) {
     tokenEndpoint = Uri.parse(tokenEndpoint);
   }
   var expiration = parsed['expiration'];
   if (expiration != null) {
     validate(expiration is int,
         'field "expiration" was not an int, was "$expiration"');
     expiration = new DateTime.fromMillisecondsSinceEpoch(expiration);
   }

   return new Credentials(
       parsed['accessToken'],
       parsed['refreshToken'],
       tokenEndpoint,
       scopes,
       expiration);
 }

 /// Serializes a set of credentials to JSON. Nothing is guaranteed about the
 /// output except that it's valid JSON and compatible with
 /// [Credentials.toJson].
 String toJson() =&gt; JSON.stringify({
   'accessToken': accessToken,
   'refreshToken': refreshToken,
   'tokenEndpoint': tokenEndpoint == null ? null : tokenEndpoint.toString(),
   'scopes': scopes,
   'expiration': expiration == null ? null : expiration.millisecondsSinceEpoch
 });

 /// Returns a new set of refreshed credentials. See [Client.identifier] and
 /// [Client.secret] for explanations of those parameters.
 ///
 /// You may request different scopes than the default by passing in
 /// [newScopes]. These must be a subset of [scopes].
 ///
 /// This will throw a [StateError] if these credentials can't be refreshed, an
 /// [AuthorizationException] if refreshing the credentials fails, or a
 /// [FormatError] if the authorization server returns invalid responses.
 Future&lt;Credentials&gt; refresh(
     String identifier,
     String secret,
     {List&lt;String&gt; newScopes,
      http.Client httpClient}) {
   var scopes = this.scopes;
   if (newScopes != null) scopes = newScopes;
   if (scopes == null) scopes = &lt;String&gt;[];
   if (httpClient == null) httpClient = new http.Client();

   var startTime = new DateTime.now();
   return async.then((_) {
     if (refreshToken == null) {
       throw new StateError("Can't refresh credentials without a refresh "
           "token.");
     } else if (tokenEndpoint == null) {
       throw new StateError("Can't refresh credentials without a token "
           "endpoint.");
     }

     var fields = {
       "grant_type": "refresh_token",
       "refresh_token": refreshToken,
       // TODO(nweiz): the spec recommends that HTTP basic auth be used in
       // preference to form parameters, but Google doesn't support that.
       // Should it be configurable?
       "client_id": identifier,
       "client_secret": secret
     };
     if (!scopes.isEmpty) fields["scope"] = scopes.join(' ');

     return httpClient.post(tokenEndpoint, fields: fields);
   }).then((response) {
     return handleAccessTokenResponse(
         response, tokenEndpoint, startTime, scopes);
   }).then((credentials) {
     // The authorization server may issue a new refresh token. If it doesn't,
     // we should re-use the one we already have.
     if (credentials.refreshToken != null) return credentials;
     return new Credentials(
         credentials.accessToken,
         this.refreshToken,
         credentials.tokenEndpoint,
         credentials.scopes,
         credentials.expiration);
   });
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Credentials</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> accessToken, [<a href="http://api.dartlang.org/dart_core/String.html">String</a> refreshToken, <a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a> tokenEndpoint, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; scopes, <a href="http://api.dartlang.org/dart_core/DateTime.html">DateTime</a> expiration]) <a class="anchor-link" href="#"
              title="Permalink to Credentials.Credentials">#</a></h4>
<div class="doc">
<p>Creates a new set of credentials.</p>
<p>This class is usually not constructed directly; rather, it's accessed via
<code>Client.credentials</code> after a <code>Client</code> is created by
<code>AuthorizationCodeGrant</code>. Alternately, it may be loaded from a serialized
form via <a class="crossref" href="../credentials/Credentials.html#fromJson">Credentials.fromJson</a>.</p>
<pre class="source">
Credentials(
   this.accessToken,
   [this.refreshToken,
    this.tokenEndpoint,
    this.scopes,
    this.expiration]);
</pre>
</div>
</div>
<div class="method"><h4 id="fromJson">
<button class="show-code">Code</button>
factory <strong>Credentials.fromJson</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> json) <a class="anchor-link" href="#fromJson"
              title="Permalink to Credentials.Credentials.fromJson">#</a></h4>
<div class="doc">
<p>Loads a set of credentials from a JSON-serialized form. Throws
<a class="crossref" href="../dart_core/FormatException.html">FormatException</a> if the JSON is incorrectly formatted.</p>
<pre class="source">
factory Credentials.fromJson(String json) {
 void validate(bool condition, String message) {
   if (condition) return;
   throw new FormatException(
       "Failed to load credentials: $message.\n\n$json");
 }

 var parsed;
 try {
   parsed = JSON.parse(json);
 } catch (e) {
   // TODO(nweiz): narrow this catch clause once issue 6775 is fixed.
   validate(false, 'invalid JSON');
 }

 validate(parsed is Map, 'was not a JSON map');
 validate(parsed.containsKey('accessToken'),
     'did not contain required field "accessToken"');
 validate(parsed['accessToken'] is String,
     'required field "accessToken" was not a string, was '
     '${parsed["accessToken"]}');


 for (var stringField in ['refreshToken', 'tokenEndpoint']) {
   var value = parsed[stringField];
   validate(value == null || value is String,
       'field "$stringField" was not a string, was "$value"');
 }

 var scopes = parsed['scopes'];
 validate(scopes == null || scopes is List,
     'field "scopes" was not a list, was "$scopes"');

 var tokenEndpoint = parsed['tokenEndpoint'];
 if (tokenEndpoint != null) {
   tokenEndpoint = Uri.parse(tokenEndpoint);
 }
 var expiration = parsed['expiration'];
 if (expiration != null) {
   validate(expiration is int,
       'field "expiration" was not an int, was "$expiration"');
   expiration = new DateTime.fromMillisecondsSinceEpoch(expiration);
 }

 return new Credentials(
     parsed['accessToken'],
     parsed['refreshToken'],
     tokenEndpoint,
     scopes,
     expiration);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="accessToken">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>accessToken</strong> <a class="anchor-link"
            href="#accessToken"
            title="Permalink to Credentials.accessToken">#</a>
        </h4>
        <div class="doc">
<p>The token that is sent to the resource server to prove the authorization
of a client.</p>
<pre class="source">
final String accessToken
</pre>
</div>
</div>
<div class="field"><h4 id="canRefresh">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>canRefresh</strong> <a class="anchor-link"
            href="#canRefresh"
            title="Permalink to Credentials.canRefresh">#</a>
        </h4>
        <div class="doc">
<p>Whether it's possible to refresh these credentials.</p>
<pre class="source">
bool get canRefresh =&gt; refreshToken != null &amp;&amp; tokenEndpoint != null;
</pre>
</div>
</div>
<div class="field"><h4 id="expiration">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/DateTime.html">DateTime</a>         <strong>expiration</strong> <a class="anchor-link"
            href="#expiration"
            title="Permalink to Credentials.expiration">#</a>
        </h4>
        <div class="doc">
<p>The date at which these credentials will expire. This is likely to be a
few seconds earlier than the server's idea of the expiration date.</p>
<pre class="source">
final DateTime expiration
</pre>
</div>
</div>
<div class="field"><h4 id="isExpired">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>isExpired</strong> <a class="anchor-link"
            href="#isExpired"
            title="Permalink to Credentials.isExpired">#</a>
        </h4>
        <div class="doc">
<p>Whether or not these credentials have expired. Note that it's possible the
credentials will expire shortly after this is called. However, since the
client's expiration date is kept a few seconds earlier than the server's,
there should be enough leeway to rely on this.</p>
<pre class="source">
bool get isExpired =&gt; expiration != null &amp;&amp;
   new DateTime.now().isAfter(expiration);
</pre>
</div>
</div>
<div class="field"><h4 id="refreshToken">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>refreshToken</strong> <a class="anchor-link"
            href="#refreshToken"
            title="Permalink to Credentials.refreshToken">#</a>
        </h4>
        <div class="doc">
<p>The token that is sent to the authorization server to refresh the
credentials. This is optional.</p>
<pre class="source">
final String refreshToken
</pre>
</div>
</div>
<div class="field"><h4 id="scopes">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt;         <strong>scopes</strong> <a class="anchor-link"
            href="#scopes"
            title="Permalink to Credentials.scopes">#</a>
        </h4>
        <div class="doc">
<p>The specific permissions being requested from the authorization server.
The scope strings are specific to the authorization server and may be
found in its documentation.</p>
<pre class="source">
final List&lt;String&gt; scopes
</pre>
</div>
</div>
<div class="field"><h4 id="tokenEndpoint">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a>         <strong>tokenEndpoint</strong> <a class="anchor-link"
            href="#tokenEndpoint"
            title="Permalink to Credentials.tokenEndpoint">#</a>
        </h4>
        <div class="doc">
<p>The URL of the authorization server endpoint that's used to refresh the
credentials. This is optional.</p>
<pre class="source">
final Uri tokenEndpoint
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="refresh">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../credentials/Credentials.html">Credentials</a>&gt; <strong>refresh</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> identifier, <a href="http://api.dartlang.org/dart_core/String.html">String</a> secret, {<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; newScopes, <a href="../client/Client.html">Client</a> httpClient}) <a class="anchor-link" href="#refresh"
              title="Permalink to Credentials.refresh">#</a></h4>
<div class="doc">
<p>Returns a new set of refreshed credentials. See <code>Client.identifier</code> and
<code>Client.secret</code> for explanations of those parameters.</p>
<p>You may request different scopes than the default by passing in

<span class="param">newScopes</span>. These must be a subset of <a class="crossref" href="../credentials/Credentials.html#scopes">scopes</a>.</p>
<p>This will throw a <a class="crossref" href="../dart_core/StateError.html">StateError</a> if these credentials can't be refreshed, an
<code>AuthorizationException</code> if refreshing the credentials fails, or a
<code>FormatError</code> if the authorization server returns invalid responses.</p>
<pre class="source">
Future&lt;Credentials&gt; refresh(
   String identifier,
   String secret,
   {List&lt;String&gt; newScopes,
    http.Client httpClient}) {
 var scopes = this.scopes;
 if (newScopes != null) scopes = newScopes;
 if (scopes == null) scopes = &lt;String&gt;[];
 if (httpClient == null) httpClient = new http.Client();

 var startTime = new DateTime.now();
 return async.then((_) {
   if (refreshToken == null) {
     throw new StateError("Can't refresh credentials without a refresh "
         "token.");
   } else if (tokenEndpoint == null) {
     throw new StateError("Can't refresh credentials without a token "
         "endpoint.");
   }

   var fields = {
     "grant_type": "refresh_token",
     "refresh_token": refreshToken,
     // TODO(nweiz): the spec recommends that HTTP basic auth be used in
     // preference to form parameters, but Google doesn't support that.
     // Should it be configurable?
     "client_id": identifier,
     "client_secret": secret
   };
   if (!scopes.isEmpty) fields["scope"] = scopes.join(' ');

   return httpClient.post(tokenEndpoint, fields: fields);
 }).then((response) {
   return handleAccessTokenResponse(
       response, tokenEndpoint, startTime, scopes);
 }).then((credentials) {
   // The authorization server may issue a new refresh token. If it doesn't,
   // we should re-use the one we already have.
   if (credentials.refreshToken != null) return credentials;
   return new Credentials(
       credentials.accessToken,
       this.refreshToken,
       credentials.tokenEndpoint,
       credentials.scopes,
       credentials.expiration);
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="toJson">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a> <strong>toJson</strong>() <a class="anchor-link" href="#toJson"
              title="Permalink to Credentials.toJson">#</a></h4>
<div class="doc">
<p>Serializes a set of credentials to JSON. Nothing is guaranteed about the
output except that it's valid JSON and compatible with
<a class="crossref" href="../credentials/Credentials.html#toJson">Credentials.toJson</a>.</p>
<pre class="source">
String toJson() =&gt; JSON.stringify({
 'accessToken': accessToken,
 'refreshToken': refreshToken,
 'tokenEndpoint': tokenEndpoint == null ? null : tokenEndpoint.toString(),
 'scopes': scopes,
 'expiration': expiration == null ? null : expiration.millisecondsSinceEpoch
});
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
