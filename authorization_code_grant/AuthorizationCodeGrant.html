        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>AuthorizationCodeGrant class / authorization_code_grant Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="authorization_code_grant" data-type="AuthorizationCodeGrant">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../authorization_code_grant.html">authorization_code_grant</a> &rsaquo; <a href="../authorization_code_grant/AuthorizationCodeGrant.html">AuthorizationCodeGrant</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>AuthorizationCodeGrant</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A class for obtaining credentials via an <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.1">authorization code grant</a>. This
method of authorization involves sending the resource owner to the
authorization server where they will authorize the client. They're then
redirected back to your server, along with an authorization code. This is
used to obtain <code>Credentials</code> and create a fully-authorized <a class="crossref" href="../oauth2_client/Client.html">Client</a>.</p>
<p>To use this class, you must first call <a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#getAuthorizationUrl">getAuthorizationUrl</a> to get the URL
to which to redirect the resource owner. Then once they've been redirected
back to your application, call <a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#handleAuthorizationResponse">handleAuthorizationResponse</a> or
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#handleAuthorizationCode">handleAuthorizationCode</a> to process the authorization server's response and
construct a <a class="crossref" href="../oauth2_client/Client.html">Client</a>.</p>
<pre class="source">
class AuthorizationCodeGrant {
 /// An enum value for [_state] indicating that [getAuthorizationUrl] has not
 /// yet been called for this grant.
 static const _INITIAL_STATE = 0;

 // An enum value for [_state] indicating that [getAuthorizationUrl] has been
 // called but neither [handleAuthorizationResponse] nor
 // [handleAuthorizationCode] has been called.
 static const _AWAITING_RESPONSE_STATE = 1;

 // An enum value for [_state] indicating that [getAuthorizationUrl] and either
 // [handleAuthorizationResponse] or [handleAuthorizationCode] have been
 // called.
 static const _FINISHED_STATE = 2;

 /// The client identifier for this client. The authorization server will issue
 /// each client a separate client identifier and secret, which allows the
 /// server to tell which client is accessing it. Some servers may also have an
 /// anonymous identifier/secret pair that any client may use.
 ///
 /// This is usually global to the program using this library.
 final String identifier;

 /// The client secret for this client. The authorization server will issue
 /// each client a separate client identifier and secret, which allows the
 /// server to tell which client is accessing it. Some servers may also have an
 /// anonymous identifier/secret pair that any client may use.
 ///
 /// This is usually global to the program using this library.
 ///
 /// Note that clients whose source code or binary executable is readily
 /// available may not be able to make sure the client secret is kept a secret.
 /// This is fine; OAuth2 servers generally won't rely on knowing with
 /// certainty that a client is who it claims to be.
 final String secret;

 /// A URL provided by the authorization server that serves as the base for the
 /// URL that the resource owner will be redirected to to authorize this
 /// client. This will usually be listed in the authorization server's
 /// OAuth2 API documentation.
 final Uri authorizationEndpoint;

 /// A URL provided by the authorization server that this library uses to
 /// obtain long-lasting credentials. This will usually be listed in the
 /// authorization server's OAuth2 API documentation.
 final Uri tokenEndpoint;

 /// The HTTP client used to make HTTP requests.
 http.Client _httpClient;

 /// The URL to which the resource owner will be redirected after they
 /// authorize this client with the authorization server.
 Uri _redirectEndpoint;

 /// The scopes that the client is requesting access to.
 List&lt;String&gt; _scopes;

 /// An opaque string that users of this library may specify that will be
 /// included in the response query parameters.
 String _stateString;

 /// The current state of the grant object. One of [_INITIAL_STATE],
 /// [_AWAITING_RESPONSE_STATE], or [_FINISHED_STATE].
 int _state = _INITIAL_STATE;

 /// Creates a new grant.
 ///
 /// [httpClient] is used for all HTTP requests made by this grant, as well as
 /// those of the [Client] is constructs.
 AuthorizationCodeGrant(
     this.identifier,
     this.secret,
     this.authorizationEndpoint,
     this.tokenEndpoint,
     {http.Client httpClient})
   : _httpClient = httpClient == null ? new http.Client() : httpClient;

 /// Returns the URL to which the resource owner should be redirected to
 /// authorize this client. The resource owner will then be redirected to
 /// [redirect], which should point to a server controlled by the client. This
 /// redirect will have additional query parameters that should be passed to
 /// [handleAuthorizationResponse].
 ///
 /// The specific permissions being requested from the authorization server may
 /// be specified via [scopes]. The scope strings are specific to the
 /// authorization server and may be found in its documentation. Note that you
 /// may not be granted access to every scope you request; you may check the
 /// [Credentials.scopes] field of [Client.credentials] to see which scopes you
 /// were granted.
 ///
 /// An opaque [state] string may also be passed that will be present in the
 /// query parameters provided to the redirect URL.
 ///
 /// It is a [StateError] to call this more than once.
 Uri getAuthorizationUrl(Uri redirect,
     {List&lt;String&gt; scopes: const &lt;String&gt;[], String state}) {
   if (_state != _INITIAL_STATE) {
     throw new StateError('The authorization URL has already been generated.');
   }
   _state = _AWAITING_RESPONSE_STATE;

   this._redirectEndpoint = redirect;
   this._scopes = scopes;
   this._stateString = state;
   var parameters = {
     "response_type": "code",
     "client_id": this.identifier,
     "redirect_uri": redirect.toString()
   };

   if (state != null) parameters['state'] = state;
   if (!scopes.isEmpty) parameters['scope'] = scopes.join(' ');

   return addQueryParameters(this.authorizationEndpoint, parameters);
 }

 /// Processes the query parameters added to a redirect from the authorization
 /// server. Note that this "response" is not an HTTP response, but rather the
 /// data passed to a server controlled by the client as query parameters on
 /// the redirect URL.
 ///
 /// It is a [StateError] to call this more than once, to call it before
 /// [getAuthorizationUrl] is called, or to call it after
 /// [handleAuthorizationCode] is called.
 ///
 /// Throws [FormatError] if [parameters] is invalid according to the OAuth2
 /// spec or if the authorization server otherwise provides invalid responses.
 /// If `state` was passed to [getAuthorizationUrl], this will throw a
 /// [FormatError] if the `state` parameter doesn't match the original value.
 ///
 /// Throws [AuthorizationException] if the authorization fails.
 Future&lt;Client&gt; handleAuthorizationResponse(Map&lt;String, String&gt; parameters) {
   return async.then((_) {
     if (_state == _INITIAL_STATE) {
       throw new StateError(
           'The authorization URL has not yet been generated.');
     } else if (_state == _FINISHED_STATE) {
       throw new StateError(
           'The authorization code has already been received.');
     }
     _state = _FINISHED_STATE;

     if (_stateString != null) {
       if (!parameters.containsKey('state')) {
         throw new FormatException('Invalid OAuth response for '
             '"$authorizationEndpoint": parameter "state" expected to be '
             '"$_stateString", was missing.');
       } else if (parameters['state'] != _stateString) {
         throw new FormatException('Invalid OAuth response for '
             '"$authorizationEndpoint": parameter "state" expected to be '
             '"$_stateString", was "${parameters['state']}".');
       }
     }

     if (parameters.containsKey('error')) {
       var description = parameters['error_description'];
       var uriString = parameters['error_uri'];
       var uri = uriString == null ? null : Uri.parse(uriString);
       throw new AuthorizationException(parameters['error'], description, uri);
     } else if (!parameters.containsKey('code')) {
       throw new FormatException('Invalid OAuth response for '
           '"$authorizationEndpoint": did not contain required parameter '
           '"code".');
     }

     return _handleAuthorizationCode(parameters['code']);
   });
 }

 /// Processes an authorization code directly. Usually
 /// [handleAuthorizationResponse] is preferable to this method, since it
 /// validates all of the query parameters. However, some authorization servers
 /// allow the user to copy and paste an authorization code into a command-line
 /// application, in which case this method must be used.
 ///
 /// It is a [StateError] to call this more than once, to call it before
 /// [getAuthorizationUrl] is called, or to call it after
 /// [handleAuthorizationCode] is called.
 ///
 /// Throws [FormatError] if the authorization server provides invalid
 /// responses while retrieving credentials.
 ///
 /// Throws [AuthorizationException] if the authorization fails.
 Future&lt;Client&gt; handleAuthorizationCode(String authorizationCode) {
   return async.then((_) {
     if (_state == _INITIAL_STATE) {
       throw new StateError(
           'The authorization URL has not yet been generated.');
     } else if (_state == _FINISHED_STATE) {
       throw new StateError(
           'The authorization code has already been received.');
     }
     _state = _FINISHED_STATE;

     return _handleAuthorizationCode(authorizationCode);
   });
 }

 /// This works just like [handleAuthorizationCode], except it doesn't validate
 /// the state beforehand.
 Future&lt;Client&gt; _handleAuthorizationCode(String authorizationCode) {
   var startTime = new DateTime.now();
   return _httpClient.post(this.tokenEndpoint, fields: {
     "grant_type": "authorization_code",
     "code": authorizationCode,
     "redirect_uri": this._redirectEndpoint.toString(),
     // TODO(nweiz): the spec recommends that HTTP basic auth be used in
     // preference to form parameters, but Google doesn't support that. Should
     // it be configurable?
     "client_id": this.identifier,
     "client_secret": this.secret
   }).then((response) {
     var credentials = handleAccessTokenResponse(
         response, tokenEndpoint, startTime, _scopes);
     return new Client(
         this.identifier, this.secret, credentials, httpClient: _httpClient);
   });
 }

 /// Closes the grant and frees its resources.
 ///
 /// This will close the underlying HTTP client, which is shared by the
 /// [Client] created by this grant, so it's not safe to close the grant and
 /// continue using the client.
 void close() {
   if (_httpClient != null) _httpClient.close();
   _httpClient = null;
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>AuthorizationCodeGrant</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> identifier, <a href="http://api.dartlang.org/dart_core/String.html">String</a> secret, <a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a> authorizationEndpoint, <a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a> tokenEndpoint, {<a href="../client/Client.html">Client</a> httpClient}) <a class="anchor-link" href="#"
              title="Permalink to AuthorizationCodeGrant.AuthorizationCodeGrant">#</a></h4>
<div class="doc">
<p>Creates a new grant.</p>
<p>
<span class="param">httpClient</span> is used for all HTTP requests made by this grant, as well as
those of the <a class="crossref" href="../oauth2_client/Client.html">Client</a> is constructs.</p>
<pre class="source">
AuthorizationCodeGrant(
   this.identifier,
   this.secret,
   this.authorizationEndpoint,
   this.tokenEndpoint,
   {http.Client httpClient})
 : _httpClient = httpClient == null ? new http.Client() : httpClient;
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="authorizationEndpoint">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a>         <strong>authorizationEndpoint</strong> <a class="anchor-link"
            href="#authorizationEndpoint"
            title="Permalink to AuthorizationCodeGrant.authorizationEndpoint">#</a>
        </h4>
        <div class="doc">
<p>A URL provided by the authorization server that serves as the base for the
URL that the resource owner will be redirected to to authorize this
client. This will usually be listed in the authorization server's
OAuth2 API documentation.</p>
<pre class="source">
final Uri authorizationEndpoint
</pre>
</div>
</div>
<div class="field"><h4 id="identifier">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>identifier</strong> <a class="anchor-link"
            href="#identifier"
            title="Permalink to AuthorizationCodeGrant.identifier">#</a>
        </h4>
        <div class="doc">
<p>The client identifier for this client. The authorization server will issue
each client a separate client identifier and secret, which allows the
server to tell which client is accessing it. Some servers may also have an
anonymous identifier/secret pair that any client may use.</p>
<p>This is usually global to the program using this library.</p>
<pre class="source">
final String identifier
</pre>
</div>
</div>
<div class="field"><h4 id="secret">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>secret</strong> <a class="anchor-link"
            href="#secret"
            title="Permalink to AuthorizationCodeGrant.secret">#</a>
        </h4>
        <div class="doc">
<p>The client secret for this client. The authorization server will issue
each client a separate client identifier and secret, which allows the
server to tell which client is accessing it. Some servers may also have an
anonymous identifier/secret pair that any client may use.</p>
<p>This is usually global to the program using this library.</p>
<p>Note that clients whose source code or binary executable is readily
available may not be able to make sure the client secret is kept a secret.
This is fine; OAuth2 servers generally won't rely on knowing with
certainty that a client is who it claims to be.</p>
<pre class="source">
final String secret
</pre>
</div>
</div>
<div class="field"><h4 id="tokenEndpoint">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a>         <strong>tokenEndpoint</strong> <a class="anchor-link"
            href="#tokenEndpoint"
            title="Permalink to AuthorizationCodeGrant.tokenEndpoint">#</a>
        </h4>
        <div class="doc">
<p>A URL provided by the authorization server that this library uses to
obtain long-lasting credentials. This will usually be listed in the
authorization server's OAuth2 API documentation.</p>
<pre class="source">
final Uri tokenEndpoint
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
void <strong>close</strong>() <a class="anchor-link" href="#close"
              title="Permalink to AuthorizationCodeGrant.close">#</a></h4>
<div class="doc">
<p>Closes the grant and frees its resources.</p>
<p>This will close the underlying HTTP client, which is shared by the
<a class="crossref" href="../oauth2_client/Client.html">Client</a> created by this grant, so it's not safe to close the grant and
continue using the client.</p>
<pre class="source">
void close() {
 if (_httpClient != null) _httpClient.close();
 _httpClient = null;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getAuthorizationUrl">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a> <strong>getAuthorizationUrl</strong>(<a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a> redirect, {<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; scopes: const<String>[] , <a href="http://api.dartlang.org/dart_core/String.html">String</a> state}) <a class="anchor-link" href="#getAuthorizationUrl"
              title="Permalink to AuthorizationCodeGrant.getAuthorizationUrl">#</a></h4>
<div class="doc">
<p>Returns the URL to which the resource owner should be redirected to
authorize this client. The resource owner will then be redirected to

<span class="param">redirect</span>, which should point to a server controlled by the client. This
redirect will have additional query parameters that should be passed to
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#handleAuthorizationResponse">handleAuthorizationResponse</a>.</p>
<p>The specific permissions being requested from the authorization server may
be specified via 
<span class="param">scopes</span>. The scope strings are specific to the
authorization server and may be found in its documentation. Note that you
may not be granted access to every scope you request; you may check the
<code>Credentials.scopes</code> field of <a class="crossref" href="../oauth2_client/Client.html#credentials">Client.credentials</a> to see which scopes you
were granted.</p>
<p>An opaque 
<span class="param">state</span> string may also be passed that will be present in the
query parameters provided to the redirect URL.</p>
<p>It is a <a class="crossref" href="../dart_core/StateError.html">StateError</a> to call this more than once.</p>
<pre class="source">
Uri getAuthorizationUrl(Uri redirect,
   {List&lt;String&gt; scopes: const &lt;String&gt;[], String state}) {
 if (_state != _INITIAL_STATE) {
   throw new StateError('The authorization URL has already been generated.');
 }
 _state = _AWAITING_RESPONSE_STATE;

 this._redirectEndpoint = redirect;
 this._scopes = scopes;
 this._stateString = state;
 var parameters = {
   "response_type": "code",
   "client_id": this.identifier,
   "redirect_uri": redirect.toString()
 };

 if (state != null) parameters['state'] = state;
 if (!scopes.isEmpty) parameters['scope'] = scopes.join(' ');

 return addQueryParameters(this.authorizationEndpoint, parameters);
}
</pre>
</div>
</div>
<div class="method"><h4 id="handleAuthorizationCode">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../oauth2_client/Client.html">Client</a>&gt; <strong>handleAuthorizationCode</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> authorizationCode) <a class="anchor-link" href="#handleAuthorizationCode"
              title="Permalink to AuthorizationCodeGrant.handleAuthorizationCode">#</a></h4>
<div class="doc">
<p>Processes an authorization code directly. Usually
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#handleAuthorizationResponse">handleAuthorizationResponse</a> is preferable to this method, since it
validates all of the query parameters. However, some authorization servers
allow the user to copy and paste an authorization code into a command-line
application, in which case this method must be used.</p>
<p>It is a <a class="crossref" href="../dart_core/StateError.html">StateError</a> to call this more than once, to call it before
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#getAuthorizationUrl">getAuthorizationUrl</a> is called, or to call it after
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#handleAuthorizationCode">handleAuthorizationCode</a> is called.</p>
<p>Throws <code>FormatError</code> if the authorization server provides invalid
responses while retrieving credentials.</p>
<p>Throws <a class="crossref" href="../authorization_exception/AuthorizationException.html">AuthorizationException</a> if the authorization fails.</p>
<pre class="source">
Future&lt;Client&gt; handleAuthorizationCode(String authorizationCode) {
 return async.then((_) {
   if (_state == _INITIAL_STATE) {
     throw new StateError(
         'The authorization URL has not yet been generated.');
   } else if (_state == _FINISHED_STATE) {
     throw new StateError(
         'The authorization code has already been received.');
   }
   _state = _FINISHED_STATE;

   return _handleAuthorizationCode(authorizationCode);
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="handleAuthorizationResponse">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../oauth2_client/Client.html">Client</a>&gt; <strong>handleAuthorizationResponse</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; parameters) <a class="anchor-link" href="#handleAuthorizationResponse"
              title="Permalink to AuthorizationCodeGrant.handleAuthorizationResponse">#</a></h4>
<div class="doc">
<p>Processes the query parameters added to a redirect from the authorization
server. Note that this "response" is not an HTTP response, but rather the
data passed to a server controlled by the client as query parameters on
the redirect URL.</p>
<p>It is a <a class="crossref" href="../dart_core/StateError.html">StateError</a> to call this more than once, to call it before
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#getAuthorizationUrl">getAuthorizationUrl</a> is called, or to call it after
<a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#handleAuthorizationCode">handleAuthorizationCode</a> is called.</p>
<p>Throws <code>FormatError</code> if 
<span class="param">parameters</span> is invalid according to the OAuth2
spec or if the authorization server otherwise provides invalid responses.
If <code>state</code> was passed to <a class="crossref" href="../authorization_code_grant/AuthorizationCodeGrant.html#getAuthorizationUrl">getAuthorizationUrl</a>, this will throw a
<code>FormatError</code> if the <code>state</code> parameter doesn't match the original value.</p>
<p>Throws <a class="crossref" href="../authorization_exception/AuthorizationException.html">AuthorizationException</a> if the authorization fails.</p>
<pre class="source">
Future&lt;Client&gt; handleAuthorizationResponse(Map&lt;String, String&gt; parameters) {
 return async.then((_) {
   if (_state == _INITIAL_STATE) {
     throw new StateError(
         'The authorization URL has not yet been generated.');
   } else if (_state == _FINISHED_STATE) {
     throw new StateError(
         'The authorization code has already been received.');
   }
   _state = _FINISHED_STATE;

   if (_stateString != null) {
     if (!parameters.containsKey('state')) {
       throw new FormatException('Invalid OAuth response for '
           '"$authorizationEndpoint": parameter "state" expected to be '
           '"$_stateString", was missing.');
     } else if (parameters['state'] != _stateString) {
       throw new FormatException('Invalid OAuth response for '
           '"$authorizationEndpoint": parameter "state" expected to be '
           '"$_stateString", was "${parameters['state']}".');
     }
   }

   if (parameters.containsKey('error')) {
     var description = parameters['error_description'];
     var uriString = parameters['error_uri'];
     var uri = uriString == null ? null : Uri.parse(uriString);
     throw new AuthorizationException(parameters['error'], description, uri);
   } else if (!parameters.containsKey('code')) {
     throw new FormatException('Invalid OAuth response for '
         '"$authorizationEndpoint": did not contain required parameter '
         '"code".');
   }

   return _handleAuthorizationCode(parameters['code']);
 });
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
