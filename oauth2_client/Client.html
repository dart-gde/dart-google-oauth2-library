        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Client class / oauth2_client Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="oauth2_client" data-type="Client">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../oauth2_client.html">oauth2_client</a> &rsaquo; <a href="../oauth2_client/Client.html">Client</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Client</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An OAuth2 client. This acts as a drop-in replacement for an <code>http.Client</code>,
while sending OAuth2 authorization credentials along with each request.</p>
<p>The client also automatically refreshes its credentials if possible. When it
makes a request, if its credentials are expired, it will first refresh them.
This means that any request may throw an <code>AuthorizationException</code> if the
refresh is not authorized for some reason, a <code>FormatException</code> if the
authorization server provides ill-formatted responses, or an
<code>ExpirationException</code> if the credentials are expired and can't be refreshed.</p>
<p>The client will also throw an <code>AuthorizationException</code> if the resource
server returns a 401 response with a WWW-Authenticate header indicating that
the current credentials are invalid.</p>
<p>If you already have a set of <code>Credentials</code>, you can construct a <a class="crossref" href="../oauth2_client/Client.html#Client">Client</a>
directly. However, in order to first obtain the credentials, you must
authorize. At the time of writing, the only authorization method this
library supports is <code>AuthorizationCodeGrant</code>.</p>
<pre class="source">
class Client extends http.BaseClient {
 /// The client identifier for this client. The authorization server will issue
 /// each client a separate client identifier and secret, which allows the
 /// server to tell which client is accessing it. Some servers may also have an
 /// anonymous identifier/secret pair that any client may use.
 ///
 /// This is usually global to the program using this library.
 final String identifier;

 /// The client secret for this client. The authorization server will issue
 /// each client a separate client identifier and secret, which allows the
 /// server to tell which client is accessing it. Some servers may also have an
 /// anonymous identifier/secret pair that any client may use.
 ///
 /// This is usually global to the program using this library.
 ///
 /// Note that clients whose source code or binary executable is readily
 /// available may not be able to make sure the client secret is kept a secret.
 /// This is fine; OAuth2 servers generally won't rely on knowing with
 /// certainty that a client is who it claims to be.
 final String secret;

 /// The credentials this client uses to prove to the resource server that it's
 /// authorized. This may change from request to request as the credentials
 /// expire and the client refreshes them automatically.
 Credentials get credentials =&gt; _credentials;
 Credentials _credentials;

 /// The underlying HTTP client.
 http.Client _httpClient;

 /// Creates a new client from a pre-existing set of credentials. When
 /// authorizing a client for the first time, you should use
 /// [AuthorizationCodeGrant] instead of constructing a [Client] directly.
 ///
 /// [httpClient] is the underlying client that this forwards requests to after
 /// adding authorization credentials to them.
 Client(
     this.identifier,
     this.secret,
     this._credentials,
     {http.Client httpClient})
   : _httpClient = httpClient == null ? new http.Client() : httpClient;

 /// Sends an HTTP request with OAuth2 authorization credentials attached. This
 /// will also automatically refresh this client's [Credentials] before sending
 /// the request if necessary.
 Future&lt;http.StreamedResponse&gt; send(http.BaseRequest request) {
   return async.then((_) {
     if (!credentials.isExpired) return new Future.value();
     if (!credentials.canRefresh) throw new ExpirationException(credentials);
     return refreshCredentials();
   }).then((_) {
     request.headers['authorization'] = "Bearer ${credentials.accessToken}";
     return _httpClient.send(request);
   }).then((response) {
     if (response.statusCode != 401 ||
         !response.headers.containsKey('www-authenticate')) {
       return response;
     }

     var authenticate;
     try {
       authenticate = new AuthenticateHeader.parse(
           response.headers['www-authenticate']);
     } on FormatException catch (e) {
       return response;
     }

     if (authenticate.scheme != 'bearer') return response;

     var params = authenticate.parameters;
     if (!params.containsKey('error')) return response;

     throw new AuthorizationException(
         params['error'], params['error_description'], params['error_uri']);
   });
 }

 /// Explicitly refreshes this client's credentials. Returns this client.
 ///
 /// This will throw a [StateError] if the [Credentials] can't be refreshed, an
 /// [AuthorizationException] if refreshing the credentials fails, or a
 /// [FormatError] if the authorization server returns invalid responses.
 ///
 /// You may request different scopes than the default by passing in
 /// [newScopes]. These must be a subset of the scopes in the
 /// [Credentials.scopes] field of [Client.credentials].
 Future&lt;Client&gt; refreshCredentials([List&lt;String&gt; newScopes]) {
   return async.then((_) {
     if (!credentials.canRefresh) {
       var prefix = "OAuth credentials";
       if (credentials.isExpired) prefix = "$prefix have expired and";
       throw new StateError("$prefix can't be refreshed.");
     }

     return credentials.refresh(identifier, secret,
         newScopes: newScopes, httpClient: _httpClient);
   }).then((credentials) {
     _credentials = credentials;
     return this;
   });
 }

 /// Closes this client and its underlying HTTP client.
 void close() {
   if (_httpClient != null) _httpClient.close();
   _httpClient = null;
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../base_client/BaseClient.html">BaseClient</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>Client</strong></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Client">
<button class="show-code">Code</button>
new <strong>Client</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> identifier, <a href="http://api.dartlang.org/dart_core/String.html">String</a> secret, <a href="../credentials/Credentials.html">Credentials</a> _credentials, {<a href="../client/Client.html">Client</a> httpClient}) <a class="anchor-link" href="#Client"
              title="Permalink to Client.Client">#</a></h4>
<div class="doc">
<p>Creates a new client from a pre-existing set of credentials. When
authorizing a client for the first time, you should use
<code>AuthorizationCodeGrant</code> instead of constructing a <a class="crossref" href="../oauth2_client/Client.html#Client">Client</a> directly.</p>
<p>
<span class="param">httpClient</span> is the underlying client that this forwards requests to after
adding authorization credentials to them.</p>
<pre class="source">
Client(
   this.identifier,
   this.secret,
   this._credentials,
   {http.Client httpClient})
 : _httpClient = httpClient == null ? new http.Client() : httpClient;
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="credentials">
<button class="show-code">Code</button>
final <a href="../credentials/Credentials.html">Credentials</a>         <strong>credentials</strong> <a class="anchor-link"
            href="#credentials"
            title="Permalink to Client.credentials">#</a>
        </h4>
        <div class="doc">
<p>The credentials this client uses to prove to the resource server that it's
authorized. This may change from request to request as the credentials
expire and the client refreshes them automatically.</p>
<pre class="source">
Credentials get credentials =&gt; _credentials;
</pre>
</div>
</div>
<div class="field"><h4 id="identifier">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>identifier</strong> <a class="anchor-link"
            href="#identifier"
            title="Permalink to Client.identifier">#</a>
        </h4>
        <div class="doc">
<p>The client identifier for this client. The authorization server will issue
each client a separate client identifier and secret, which allows the
server to tell which client is accessing it. Some servers may also have an
anonymous identifier/secret pair that any client may use.</p>
<p>This is usually global to the program using this library.</p>
<pre class="source">
final String identifier
</pre>
</div>
</div>
<div class="field"><h4 id="secret">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>secret</strong> <a class="anchor-link"
            href="#secret"
            title="Permalink to Client.secret">#</a>
        </h4>
        <div class="doc">
<p>The client secret for this client. The authorization server will issue
each client a separate client identifier and secret, which allows the
server to tell which client is accessing it. Some servers may also have an
anonymous identifier/secret pair that any client may use.</p>
<p>This is usually global to the program using this library.</p>
<p>Note that clients whose source code or binary executable is readily
available may not be able to make sure the client secret is kept a secret.
This is fine; OAuth2 servers generally won't rely on knowing with
certainty that a client is who it claims to be.</p>
<pre class="source">
final String secret
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
void <strong>close</strong>() <a class="anchor-link" href="#close"
              title="Permalink to Client.close">#</a></h4>
<div class="doc">
<p>Closes this client and its underlying HTTP client.</p>
<pre class="source">
void close() {
 if (_httpClient != null) _httpClient.close();
 _httpClient = null;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="delete">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../response/Response.html">Response</a>&gt; <strong>delete</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers}) <a class="anchor-link" href="#delete"
              title="Permalink to Client.delete">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP DELETE request with the given headers to the given URL,
which can be a <code>Uri</code> or a <code>String</code>.</p>
<p>For more fine-grained control over the request, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> instead.</p>
<pre class="source">
Future&lt;Response&gt; delete(url, {Map&lt;String, String&gt; headers}) =&gt;
 _sendUnstreamed("DELETE", url, headers);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="get">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../response/Response.html">Response</a>&gt; <strong>get</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers}) <a class="anchor-link" href="#get"
              title="Permalink to Client.get">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP GET request with the given headers to the given URL, which
can be a <code>Uri</code> or a <code>String</code>.</p>
<p>For more fine-grained control over the request, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> instead.</p>
<pre class="source">
Future&lt;Response&gt; get(url, {Map&lt;String, String&gt; headers}) =&gt;
 _sendUnstreamed("GET", url, headers);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="head">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../response/Response.html">Response</a>&gt; <strong>head</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers}) <a class="anchor-link" href="#head"
              title="Permalink to Client.head">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP HEAD request with the given headers to the given URL, which
can be a <code>Uri</code> or a <code>String</code>.</p>
<p>For more fine-grained control over the request, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> instead.</p>
<pre class="source">
Future&lt;Response&gt; head(url, {Map&lt;String, String&gt; headers}) =&gt;
 _sendUnstreamed("HEAD", url, headers);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="post">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../response/Response.html">Response</a>&gt; <strong>post</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; fields}) <a class="anchor-link" href="#post"
              title="Permalink to Client.post">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP POST request with the given headers and fields to the given
URL, which can be a <code>Uri</code> or a <code>String</code>. If any fields are specified, the
content-type is automatically set to
<code>"application/x-www-form-urlencoded"</code>.</p>
<p>For more fine-grained control over the request, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> instead.</p>
<pre class="source">
Future&lt;Response&gt; post(url,
   {Map&lt;String, String&gt; headers,
    Map&lt;String, String&gt; fields}) =&gt;
 _sendUnstreamed("POST", url, headers, fields);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="put">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../response/Response.html">Response</a>&gt; <strong>put</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; fields}) <a class="anchor-link" href="#put"
              title="Permalink to Client.put">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP PUT request with the given headers and fields to the given
URL, which can be a <code>Uri</code> or a <code>String</code>. If any fields are specified, the
content-type is automatically set to
<code>"application/x-www-form-urlencoded"</code>.</p>
<p>For more fine-grained control over the request, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> instead.</p>
<pre class="source">
Future&lt;Response&gt; put(url,
   {Map&lt;String, String&gt; headers,
    Map&lt;String, String&gt; fields}) =&gt;
 _sendUnstreamed("PUT", url, headers, fields);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="read">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; <strong>read</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers}) <a class="anchor-link" href="#read"
              title="Permalink to Client.read">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP GET request with the given headers to the given URL, which
can be a <code>Uri</code> or a <code>String</code>, and returns a Future that completes to the
body of the response as a String.</p>
<p>The Future will emit an <code>HttpException</code> if the response doesn't have a
success status code.</p>
<p>For more fine-grained control over the request and response, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> or
<code>get</code> instead.</p>
<pre class="source">
Future&lt;String&gt; read(url, {Map&lt;String, String&gt; headers}) {
 return get(url, headers: headers).then((response) {
   _checkResponseSuccess(url, response);
   return response.body;
 });
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="readBytes">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_typed_data/Uint8List.html">Uint8List</a>&gt; <strong>readBytes</strong>(url, {<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; headers}) <a class="anchor-link" href="#readBytes"
              title="Permalink to Client.readBytes">#</a></h4>
<div class="inherited-from">inherited from <a href="../base_client/BaseClient.html">BaseClient</a> </div><div class="doc">
<p>Sends an HTTP GET request with the given headers to the given URL, which
can be a <code>Uri</code> or a <code>String</code>, and returns a Future that completes to the
body of the response as a list of bytes.</p>
<p>The Future will emit an <code>HttpException</code> if the response doesn't have a
success status code.</p>
<p>For more fine-grained control over the request and response, use <a class="crossref" href="../oauth2_client/Client.html#send">send</a> or
<code>get</code> instead.</p>
<pre class="source">
Future&lt;Uint8List&gt; readBytes(url, {Map&lt;String, String&gt; headers}) {
 return get(url, headers: headers).then((response) {
   _checkResponseSuccess(url, response);
   return response.bodyBytes;
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshCredentials">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../oauth2_client/Client.html">Client</a>&gt; <strong>refreshCredentials</strong>([<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; newScopes]) <a class="anchor-link" href="#refreshCredentials"
              title="Permalink to Client.refreshCredentials">#</a></h4>
<div class="doc">
<p>Explicitly refreshes this client's credentials. Returns this client.</p>
<p>This will throw a <code>StateError</code> if the <code>Credentials</code> can't be refreshed, an
<code>AuthorizationException</code> if refreshing the credentials fails, or a
<code>FormatError</code> if the authorization server returns invalid responses.</p>
<p>You may request different scopes than the default by passing in

<span class="param">newScopes</span>. These must be a subset of the scopes in the
<code>Credentials.scopes</code> field of <a class="crossref" href="../oauth2_client/Client.html#credentials">Client.credentials</a>.</p>
<pre class="source">
Future&lt;Client&gt; refreshCredentials([List&lt;String&gt; newScopes]) {
 return async.then((_) {
   if (!credentials.canRefresh) {
     var prefix = "OAuth credentials";
     if (credentials.isExpired) prefix = "$prefix have expired and";
     throw new StateError("$prefix can't be refreshed.");
   }

   return credentials.refresh(identifier, secret,
       newScopes: newScopes, httpClient: _httpClient);
 }).then((credentials) {
   _credentials = credentials;
   return this;
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="send">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../streamed_response/StreamedResponse.html">StreamedResponse</a>&gt; <strong>send</strong>(<a href="../base_request/BaseRequest.html">BaseRequest</a> request) <a class="anchor-link" href="#send"
              title="Permalink to Client.send">#</a></h4>
<div class="doc">
<p>Sends an HTTP request with OAuth2 authorization credentials attached. This
will also automatically refresh this client's <code>Credentials</code> before sending
the request if necessary.</p>
<pre class="source">
Future&lt;http.StreamedResponse&gt; send(http.BaseRequest request) {
 return async.then((_) {
   if (!credentials.isExpired) return new Future.value();
   if (!credentials.canRefresh) throw new ExpirationException(credentials);
   return refreshCredentials();
 }).then((_) {
   request.headers['authorization'] = "Bearer ${credentials.accessToken}";
   return _httpClient.send(request);
 }).then((response) {
   if (response.statusCode != 401 ||
       !response.headers.containsKey('www-authenticate')) {
     return response;
   }

   var authenticate;
   try {
     authenticate = new AuthenticateHeader.parse(
         response.headers['www-authenticate']);
   } on FormatException catch (e) {
     return response;
   }

   if (authenticate.scheme != 'bearer') return response;

   var params = authenticate.parameters;
   if (!params.containsKey('error')) return response;

   throw new AuthorizationException(
       params['error'], params['error_description'], params['error_uri']);
 });
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
