        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ErrorGroup class / error_group Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="error_group" data-type="ErrorGroup">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../error_group.html">error_group</a> &rsaquo; <a href="../error_group/ErrorGroup.html">ErrorGroup</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ErrorGroup</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An <a class="crossref" href="../error_group/ErrorGroup.html#ErrorGroup">ErrorGroup</a> entangles the errors of multiple <code>Future</code>s and <code>Stream</code>s
with one another. This allows APIs to expose multiple <code>Future</code>s and
<code>Stream</code>s that have identical error conditions without forcing API consumers
to attach error handling to objects they don't care about.</p>
<p>To use an <a class="crossref" href="../error_group/ErrorGroup.html#ErrorGroup">ErrorGroup</a>, register <code>Future</code>s and <code>Stream</code>s with it using
<a class="crossref" href="../error_group/ErrorGroup.html#registerFuture">registerFuture</a> and <a class="crossref" href="../error_group/ErrorGroup.html#registerStream">registerStream</a>. These methods return wrapped versions
of the <code>Future</code>s and <code>Stream</code>s, which should then be used in place of the
originals. For example:</p>
<pre><code>var errorGroup = new ErrorGroup();
future = errorGroup.registerFuture(future);
stream = errorGroup.registerStream(stream);
</code></pre>
<p>An <a class="crossref" href="../error_group/ErrorGroup.html#ErrorGroup">ErrorGroup</a> has two major effects on its wrapped members:</p><ul><li>
<p>An error in any member of the group will be propagated to every member
  that hasn't already completed. If those members later complete, their
  values will be ignored.</p></li><li>
<p>If any member of this group has a listener, errors on members without
  listeners won't get passed to the top-level error handler.</p></li></ul>
<pre class="source">
class ErrorGroup {
 /// The [Future]s that are members of [this].
 final _futures = &lt;_ErrorGroupFuture&gt;[];

 /// The [Stream]s that are members of [this].
 final _streams = &lt;_ErrorGroupStream&gt;[];

 /// Whether [this] has completed, either successfully or with an error.
 var _isDone = false;

 /// The [Completer] for [done].
 final _doneCompleter = new Completer();

 /// The underlying [Future] for [done]. We need to be able to access it
 /// internally as an [_ErrorGroupFuture] so we can check if it has listeners
 /// and signal errors on it.
 _ErrorGroupFuture _done;

 /// Returns a [Future] that completes successully when all members of [this]
 /// are complete, or with an error if any member receives an error.
 ///
 /// This [Future] is effectively in the group in that an error on it won't be
 /// passed to the top-level error handler unless no members of the group have
 /// listeners attached.
 Future get done =&gt; _done;

 /// Creates a new group with no members.
 ErrorGroup() {
   this._done = new _ErrorGroupFuture(this, _doneCompleter.future);
 }

 /// Registers a [Future] as a member of [this]. Returns a wrapped version of
 /// [future] that should be used in its place.
 ///
 /// If all members of [this] have already completed successfully or with an
 /// error, it's a [StateError] to try to register a new [Future].
 Future registerFuture(Future future) {
   if (_isDone) {
     throw new StateError("Can't register new members on a complete "
         "ErrorGroup.");
   }

   var wrapped = new _ErrorGroupFuture(this, future);
   _futures.add(wrapped);
   return wrapped;
 }

 /// Registers a [Stream] as a member of [this]. Returns a wrapped version of
 /// [stream] that should be used in its place. The returned [Stream] will be
 /// multi-subscription if and only if [stream] is.
 ///
 /// Since all errors in a group are passed to all members, the returned
 /// [Stream] will automatically unsubscribe all its listeners when it
 /// encounters an error.
 ///
 /// If all members of [this] have already completed successfully or with an
 /// error, it's a [StateError] to try to register a new [Stream].
 Stream registerStream(Stream stream) {
   if (_isDone) {
     throw new StateError("Can't register new members on a complete "
         "ErrorGroup.");
   }

   var wrapped = new _ErrorGroupStream(this, stream);
   _streams.add(wrapped);
   return wrapped;
 }

 /// Sends [error] to all members of [this]. Like errors that come from
 /// members, this will only be passed to the top-level error handler if no
 /// members have listeners.
 ///
 /// If all members of [this] have already completed successfully or with an
 /// error, it's a [StateError] to try to signal an error.
 void signalError(var error) {
   if (_isDone) {
     throw new StateError("Can't signal errors on a complete ErrorGroup.");
   }

   _signalError(error);
 }

 /// Signal an error internally. This is just like [signalError], but instead
 /// of throwing an error if [this] is complete, it just does nothing.
 void _signalError(var error) {
   if (_isDone) return;

   var caught = false;
   for (var future in _futures) {
     if (future._isDone || future._hasListeners) caught = true;
     future._signalError(error);
   }

   for (var stream in _streams) {
     if (stream._isDone || stream._hasListeners) caught = true;
     stream._signalError(error);
   }

   _isDone = true;
   _done._signalError(error);
   if (!caught &amp;&amp; !_done._hasListeners) error.throwDelayed();
 }

 /// Notifies [this] that one of its member [Future]s is complete.
 void _signalFutureComplete(_ErrorGroupFuture future) {
   if (_isDone) return;

   _isDone = _futures.every((future) =&gt; future._isDone) &amp;&amp;
       _streams.every((stream) =&gt; stream._isDone);
   if (_isDone) _doneCompleter.complete();
 }

 /// Notifies [this] that one of its member [Stream]s is complete.
 void _signalStreamComplete(_ErrorGroupStream stream) {
   if (_isDone) return;

   _isDone = _futures.every((future) =&gt; future._isDone) &amp;&amp;
       _streams.every((stream) =&gt; stream._isDone);
   if (_isDone) _doneCompleter.complete();
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="ErrorGroup">
<button class="show-code">Code</button>
new <strong>ErrorGroup</strong>() <a class="anchor-link" href="#ErrorGroup"
              title="Permalink to ErrorGroup.ErrorGroup">#</a></h4>
<div class="doc">
<p>Creates a new group with no members.</p>
<pre class="source">
ErrorGroup() {
 this._done = new _ErrorGroupFuture(this, _doneCompleter.future);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="done">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html">Future</a>         <strong>done</strong> <a class="anchor-link"
            href="#done"
            title="Permalink to ErrorGroup.done">#</a>
        </h4>
        <div class="doc">
<p>Returns a <code>Future</code> that completes successully when all members of <code>this</code>
are complete, or with an error if any member receives an error.</p>
<p>This <code>Future</code> is effectively in the group in that an error on it won't be
passed to the top-level error handler unless no members of the group have
listeners attached.</p>
<pre class="source">
Future get done =&gt; _done;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="registerFuture">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a> <strong>registerFuture</strong>(<a href="http://api.dartlang.org/dart_async/Future.html">Future</a> future) <a class="anchor-link" href="#registerFuture"
              title="Permalink to ErrorGroup.registerFuture">#</a></h4>
<div class="doc">
<p>Registers a <code>Future</code> as a member of <code>this</code>. Returns a wrapped version of

<span class="param">future</span> that should be used in its place.</p>
<p>If all members of <code>this</code> have already completed successfully or with an
error, it's a <code>StateError</code> to try to register a new <code>Future</code>.</p>
<pre class="source">
Future registerFuture(Future future) {
 if (_isDone) {
   throw new StateError("Can't register new members on a complete "
       "ErrorGroup.");
 }

 var wrapped = new _ErrorGroupFuture(this, future);
 _futures.add(wrapped);
 return wrapped;
}
</pre>
</div>
</div>
<div class="method"><h4 id="registerStream">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> <strong>registerStream</strong>(<a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> stream) <a class="anchor-link" href="#registerStream"
              title="Permalink to ErrorGroup.registerStream">#</a></h4>
<div class="doc">
<p>Registers a <code>Stream</code> as a member of <code>this</code>. Returns a wrapped version of

<span class="param">stream</span> that should be used in its place. The returned <code>Stream</code> will be
multi-subscription if and only if 
<span class="param">stream</span> is.</p>
<p>Since all errors in a group are passed to all members, the returned
<code>Stream</code> will automatically unsubscribe all its listeners when it
encounters an error.</p>
<p>If all members of <code>this</code> have already completed successfully or with an
error, it's a <code>StateError</code> to try to register a new <code>Stream</code>.</p>
<pre class="source">
Stream registerStream(Stream stream) {
 if (_isDone) {
   throw new StateError("Can't register new members on a complete "
       "ErrorGroup.");
 }

 var wrapped = new _ErrorGroupStream(this, stream);
 _streams.add(wrapped);
 return wrapped;
}
</pre>
</div>
</div>
<div class="method"><h4 id="signalError">
<button class="show-code">Code</button>
void <strong>signalError</strong>(error) <a class="anchor-link" href="#signalError"
              title="Permalink to ErrorGroup.signalError">#</a></h4>
<div class="doc">
<p>Sends 
<span class="param">error</span> to all members of <code>this</code>. Like errors that come from
members, this will only be passed to the top-level error handler if no
members have listeners.</p>
<p>If all members of <code>this</code> have already completed successfully or with an
error, it's a <code>StateError</code> to try to signal an error.</p>
<pre class="source">
void signalError(var error) {
 if (_isDone) {
   throw new StateError("Can't signal errors on a complete ErrorGroup.");
 }

 _signalError(error);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
